# Aula do dia 09/05/2019 


## Equals 
No início do treinamento fizemos um teste onde comparamos o valor de duas strings completamente iguals com o operador **==** e de forma surpreendente o resultado era false. 
Isso se dá pois o operador == não verifica igualdade de valor e sim de referência, isto é, retorna true apenas se os dois lados do operador apontam para a mesma referência em memória. Como no caso das strings as duas apontavam para referências distintas o resultado era sempre false.
Quando desejamos comparar a identidade de dois objetos é necessário utilizar o método equals. No caso da String o método equals foi implementado para levar em consideração o conteúdo (valor) dos dois objetos. 
No caso das nossas classes em específico, como nós não implementamos o método, a implementação disponível é a mesma da classe Object (lembrem-se que toda classe java herda a classe Object).
Dessa forma é importante sobescrevermos o método equals em nossos beans para que as operações que dependem de verificação de igualdade funcionem da maneria correta. 
Segue abaixo exemplo de implementação de equals:
```java
...

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Entidade other = (Entidade) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}
...
```
No exemplo acima o atributo id está sendo levado em consideração para verificação da igualdade de valor entte dois objetos. 

Segundo a Documentação do Java, o contrato(Regras) de equals() segue as seguintes diretrizes:

* É reflexivo: para qualquer valor de referência x, x.equals() deve retornar true;
* É simétrico: para qualquer valor de referência x e y, x.equals(y) deve retornar true se, e somente se, y.equals(x) retornar true.
* É transitivo: para qualquer valor de referência de x, y e z, se x.equals(y) retornar true e y.equals(z) também retornar true, então, x.equals(z) deve retornar true.
* É consistente: para qualquer valor de referência de x e y, múltiplas chamadas de x.equals(y) retornarão consistentemente true ou consistentemente false, contanto que nenhuma informação usada nas comparações do objeto de equals tenha sido alterada.
Para qualquer valor de referência x que não seja null, x.equals(null) deve retornar false.

## Hashcode
O hashCode é uma ferramenta da JVM usada para montar a tabela de hash de modo correto.

Tabela Hash [também conhecida como Tabela de Dispersão ou Tabela de Espalhamento] é uma tabela onde as informações são armazenadas conforme um “numero hash” calculado com base nas propriedades da informação. Isso permite que seja muito rápido recuperar uma informação na tabela.

Vamos exemplificar o negócio: você tem uma tabela com as informações de todos os pacientes de um hospital. Se você fosse buscar um paciente em especial iria demorar um tempo (O(n) numa busca linear ou O(log N) para buscas binarias) o que pode ser extremamente ruim em uma situação real onde existe um volume de dados gigantescos. Usando uma tabela hash a busca reduz seu tempo de busca (O(1)) para qualquer situação, bastando apenas o calculo do valor hash na entrada e na saída da informação.

Um ultimo exemplo pra quem ainda não compreendeu, imagine que a tabela hash é um armário cheio de gavetas, todas com um numero na frente. Toda vez que você vai guardar alguma coisa nesse armário, primeiro se calcula um hash dessa informação [ o como a gente explica depois] e com esse número nós colocamos na gaveta especifica. Se alguns anos mais tarde precisar dessa informação, apenas calculando o hash nós podemos ir direto na gaveta certa!!!

A ideia de uma boa função hash é garantir que somente uma informação esteja em uma determinada “gaveta”, só que infelizmente isso nem sempre é possível. Quando mais de uma informação acaba em um mesmo bucket[apenas uma outra forma de se referir a “gaveta” ] acontece o que chamamos de colisão na tabela hash. Ainda assim é a melhor estratégia, pois temos que procurar apenas entre poucos objetos ao invés daquela volumosa quantidade de antes

De acordo com a documentação do Java, existe um contrato a ser seguido caso seja sobrescrito o hashCode():

* Sempre que for chamado no mesmo objeto mais de uma vez durante a execução de um aplicativo Java, o método hashCode() terá que retornar consistentemente o mesmo inteiro, contanto que nenhuma informação usada nas comparações de equals() envolvendo o objeto tenha sido alterada. Este inteiro terá que permanecer constante de uma execução a outra do mesmo aplicativo.
* Se dois objetos forem iguais de acordo com o método equals(Object), então, a chamada do método hashCode() nos dois objetos deve produzir como resultado o mesmo inteiro.
*Não é obrigatório que quando dois objetos forem diferentes de acordo com o método equals(Object), a chamada ao método hashCode() nesses objetos produza resultados inteiros distintos. No entanto, o programador deve ficar alerta para o fato de que produzir resultados inteiros distintos para objetos diferentes pode melhorar o desempenho das tabelas de hashing.
